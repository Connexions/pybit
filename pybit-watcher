#!/usr/bin/python

#       Copyright 2012:
#
#       Nick Davidson <nickd@toby-churchill.com>,
#       Simon Haswell <simonh@toby-churchill.com>,
#       Neil Williams <neilw@toby-churchill.com>,
#       James Bennet <github@james-bennet.com / James.Bennet@toby-churchill.com>
#
#       This program is free software; you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation; either version 2 of the License, or
#       (at your option) any later version.
#
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#       GNU General Public License for more details.
#
#       You should have received a copy of the GNU General Public License
#       along with this program; if not, write to the Free Software
#       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#       MA 02110-1301, USA.

# -*- coding: utf-8 -*-

import optparse
import pyinotify
import daemon
import pybit
import os
import sys
import logging

from pybit.daemonlogger import LoggingDaemonContext, FileLikeLogger

settings= {}

META="PYBIT_WATCHER_"

def getDaemonLogger (filePath, format = None) :
	FORMAT = format or '%(asctime)s %(msg)s'
	logging.basicConfig(filename=filePath, format=FORMAT, level=logging.DEBUG)
	logging.debug ("I: Daemonised")
	return logging.getLogger()

class EventHandler(pyinotify.ProcessEvent):
	def process_IN_CREATE(self, event):
		if os.path.isfile(event.pathname) and event.pathname.endswith(".changes"):
			cmd = "reprepro -b %s processincomming  %s" % (settings['repobase'], settings['rule'])
			if settings['dryrun'] == True: 
				loging.debug(cmd)
			else:
				 os.system (cmd)

if __name__ == '__main__':
	parser = optparse.OptionParser()
	#options we can override in the config file.
	groupConfigFile = optparse.OptionGroup(parser,
		"Config File Defaults","All the options which have defaults read from a config file.")
	
	groupConfigFile.add_option("--path", dest="path",
		help="Path to listen on.", metavar=META + "PATH")
	
	groupConfigFile.add_option("--repobase", dest="repobase",
		help="Base of the repository.", metavar=META + "REPOBASE")
	
	groupConfigFile.add_option("--dry-run", dest="dryrun", action="store_true", default=False,
		help="Controls if we simulate or do we actually run.", metavar=META + "DRYRUN")

	parser.add_option("--conf_file", dest="conf_file", default="watcher/watcher.conf",
		help="Config file to read settings from, defaults to watcher.conf which will be read from configs/watcher and /etc/pybit/watcher in turn.",
		metavar=META + "CONF_FILE")

	parser.add_option("-v", dest="verbose", action="store_true", default=False,
		help="Turn on verbose messages.", metavar=META+"VERBOSE")

	parser.add_option("-d", dest="daemonise", action="store_true", default=False,
		help="Daemonise with output going to /var/log/pybit-watcher", metavar=META+"DAEMONISE")
		
	
	
	(options, args) = parser.parse_args()
	
	(settings, opened_path) = pybit.load_settings(options.conf_file)
	
	if options.daemonise :
		testLogger = getDaemonLogger('/var/log/pybitwatcher.log')
		stdoutLogger = getDaemonLogger('/dev/null')
		stderrLogger = getDaemonLogger('/dev/null')
		context = LoggingDaemonContext()
		context.loggers_preserve=[testLogger]
		context.stdout_logger = stdoutLogger
		context.stderr_logger = stderrLogger
		logging.debug ("I: Daemonised")
	else :
#		FORMAT = format or '%(asctime)s %(msg)s'
		logging.basicConfig(level=logging.DEBUG)
		logging.debug ("I: Not daemonised")
	
	
	if settings == {}:
		logging.debug("Couldn't load configuration from %s" % opened_path)
		sys.exit(-1)
		
	if 'configured'  in settings and settings['configured'] == False:
		logging.debug ("Please configure the Reprepro watcher. Edit %s" % opened_path)
		sys.exit(os.EX_OK)
	
	settings = pybit.merge_options(settings, groupConfigFile, options)
	
	wm = pyinotify.WatchManager()
	mask = pyinotify.IN_CREATE
	
	handler = EventHandler()
	notifier = pyinotify.Notifier(wm, handler)
	wdd = wm.add_watch(settings['path'], mask, rec=True)
	
	
	
	if options.daemonise == True:
		with daemon.DaemonContext():
			pid = str(os.getpid())
			file(PIDFILE, 'w').write(pid)
			notifier.loop()
	else:
		logging.debug ("I: Running watcher")
		notifier.loop()
