#!/usr/bin/python

# -*- coding: utf-8 -*-
from amqplib import client_0_8 as amqp
from optparse import OptionParser

import os, tty, sys, signal, jsonpickle


from pybitweb.models import packageinstance

metaPefix="PYBIT_CLIENT_"
parser = OptionParser()

parser.add_option("--arch", dest="arch", default="i386", help="Architecture to use, defaults to i386", metavar= metaPefix + "ARCH")
parser.add_option("--ack", dest="ack", help="Does the client ack the message or reject it? If unset the client will be interactive.",metavar= metaPefix +"ACK")
parser.add_option("--distribution", dest="distribution", default="Debian", help="Distribution to use, defaults to Debian", metavar= metaPefix +"DIST")
parser.add_option("--package", dest="package", default="deb", help="Package type to use, defaults to deb", metavar= metaPefix +"PACKAGE")
parser.add_option("--suite", dest="suite", default="development", help="Suite to use, defaults to development", metavar= metaPefix +"SUITE")
parser.add_option("--host", dest="host", default="localhost", help="vhost to connect to, defaults to localhost.", metavar=metaPefix + "HOST")
parser.add_option("--vhost", dest="vhost", default="/", help="vhost to connect to, defaults to localhost.", metavar=metaPefix + "VHOST")
parser.add_option("--userid", dest="userid", default="guest", help="user id to use for AMQP server, defaults to guest.", metavar=metaPefix + "USERID")
parser.add_option("--port", dest="port", default="5672", help="port to use for AMQP server, defaults to 5672", metavar=metaPefix + "PORT")
parser.add_option("--password", dest="password", default="guest", help="password to use for AMQP server, defaults to guest", metavar=metaPefix + "PASSWORD")
parser.add_option("--insist", dest="insist", default=False, help="insist to use for AMQP server, defaults to 5672", metavar=metaPefix + "INSIST")


(options, args) = parser.parse_args()

routing_key = "%s.%s.%s.%s" % (options.distribution, options.arch, options.suite, options.package)
queue_name = "%s_%s_%s_%s" % (options.distribution, options.arch, options.suite, options.package)


print "Connecting with... \nhost: " + options.host + "\nuser id: " + options.userid + "\npassword: "  + options.password + "\nvhost: " + options.vhost + "\ninsist: " + str(options.insist)
conn = amqp.Connection(host=options.host, userid=options.userid, password=options.password, virtual_host=options.vhost, insist= options.insist)
chan = conn.channel()
print "Creating queue with name:" + str(queue_name)
chan.queue_declare(queue=queue_name, durable=True, exclusive=False, auto_delete=False)
chan.exchange_declare(exchange="pybit", type="direct", durable=True, auto_delete=False,)
chan.queue_bind(queue=queue_name, exchange="pybit", routing_key=routing_key)


def signal_handler(signal, frame):
	try:
		print '\nClosing %s' % os.path.basename(__file__)
		os._exit (os.EX_OK)
	except Exception as e:
		raise Exception('Error in signal handler: ' + str(e))
		return
		
try:
	signal.signal(signal.SIGINT, signal_handler)
	print "Hit Ctrl-C to quit."
except Exception as e:
	raise Exception('Error configuring signal handler: ' + str(e))


def recv_callback(msg):
	if options.ack not None:
		if options.ack:
			print "Accepting BUILD REQUEST ( job id", unpickled_req.job.id, ",", unpickled_req.job.packageinstance.package.name, ",", unpickled_req.job.packageinstance.package.version, ",", unpickled_req.job.packageinstance.format.name, ",", unpickled_req.job.packageinstance.arch.name, ")"			chan.basic_ack(msg.delivery_tag)
		else:
			print "Rejecting message."
			chan.basic_recover(True)
			
	else:
		while True:
			user_input = raw_input('''Recived message:
	[A]ccept:
	[R]eject
	[B]uild
	B[l]ock
	[F]ail
	''').lower()
			
			if user_input == "a":
				unpickled_req = jsonpickle.decode(msg.body)
				print "Accepting BUILD REQUEST ( job id", unpickled_req.job.id, ",", unpickled_req.job.packageinstance.package.name, ",", unpickled_req.job.packageinstance.package.version, ",", unpickled_req.job.packageinstance.format.name, ",", unpickled_req.job.packageinstance.arch.name, ")"
				chan.basic_ack(msg.delivery_tag)
				break
			elif user_input == "r":
				print "Rejecting message."
				chan.basic_recover(True)
				break
			elif user_input == "b":
				print "Unimplimented"
			elif user_input == "l":
				print "Unimplimented"
			elif user_input == "f":
				print "Unimplimented"
			else:
				print "Invalid selection."
	
try:
	chan.basic_consume(queue=queue_name, no_ack=False, callback=recv_callback, consumer_tag="build_callback")
	while True:
		chan.wait()
	# drop registration
	chan.basic_cancel("build_callback")
	chan.close()
	conn.close()
except Exception as e:
	raise e
